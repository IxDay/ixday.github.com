<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Not today...</title>
    <link>http://ixday.github.io/tags/python/</link>
    <description>Recent content in Python on Not today...</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 16 Mar 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://ixday.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Pytest command line</title>
      <link>http://ixday.github.io/post/pytest_command_line/</link>
      <pubDate>Wed, 16 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ixday.github.io/post/pytest_command_line/</guid>
      <description>I have recently dug into pytest documentation, and moreover into the command line arguments and I finally found a better workflow for running tests while I develop.
Here is the command I run when I just made some devs: py.test -xvvvs --tb=line --pdb
 -x will stop execution on first failue, useful when debugging tests in order of appearance (recommended) -vvv will display current test path (reuasable in py.test), the path will avoid to rerun all the previous tests before going to the one you are currently working on.</description>
    </item>
    
    <item>
      <title>Pdbpp</title>
      <link>http://ixday.github.io/post/pdbpp/</link>
      <pubDate>Sun, 28 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ixday.github.io/post/pdbpp/</guid>
      <description>I am a huge fan of ipython and its debugger ipdb (I have also done a patch on it). Then I discovered pdbpp and I found it so great that I no more use ipdb, here is why.
More features Sticky mode Pdbpp comes with a lot of additional features which are really convenient. The first and more well known is the sticky mode:
 This will display the code currently, executed and shows you with an arrow at which exact line you are.</description>
    </item>
    
    <item>
      <title>Listing directory with wsgi</title>
      <link>http://ixday.github.io/post/listing_directory_with_wsgi/</link>
      <pubDate>Thu, 02 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ixday.github.io/post/listing_directory_with_wsgi/</guid>
      <description>Recently I ran into an issue with my blog and pelican (the blogging engine I use). For some reasons (which I explain [here]()) I had to develop a small wsgi app which act like the python SimpleHTTPServer.
I tried a lot of things but they never worked as I wanted them to. So, I decided to do this by myself.
Specifications Here are the features I wanted:
 Define a directory as the root (/) directory from which all the files will be served.</description>
    </item>
    
    <item>
      <title>Patch dependency</title>
      <link>http://ixday.github.io/post/patch_dependency/</link>
      <pubDate>Tue, 09 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ixday.github.io/post/patch_dependency/</guid>
      <description>When developing on a project it is possible that a dependency can have an issue. First you want to be able to debug it (pdb, ipdb), then modify it if you find a bug. To do that there is a naive way in python, which consist in editing directly the sources of the module. But there is a cleaner way based on pip.
The -e option allows you to pass a path (git, http, file) for a given module and link it to your environment.</description>
    </item>
    
    <item>
      <title>Pytest Fixture</title>
      <link>http://ixday.github.io/post/pytest_fixture/</link>
      <pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ixday.github.io/post/pytest_fixture/</guid>
      <description>I am a huge fan of python (one of the best language in my toolbox). And when it comes to tests, pytest is THE library to use.
I also use Flask a lot, so today I will show you some of my snippets.
First one the app fixture:
@pytest.fixture(autouse=True) def app(): &amp;quot;&amp;quot;&amp;quot;Load flask in testing mode&amp;quot;&amp;quot;&amp;quot; app_test = myapp app_test.config[&amp;#39;TESTING&amp;#39;] = True app_test.json_encoder = my_encoder return app_test.test_client()  This create an app fixture which will be used to test the application, it returns a test client to interact with my Flask application.</description>
    </item>
    
  </channel>
</rss>